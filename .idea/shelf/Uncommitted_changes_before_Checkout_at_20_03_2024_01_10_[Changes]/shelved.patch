Index: pokemon.py
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>import pygame\r\nimport random\r\nimport objet\r\nimport game_infos\r\nimport attaques\r\nimport csv\r\n\r\n\r\nclass Pokemon:\r\n\r\n    def __init__(self, name, level, game, is_shiny=None, objet_tenu=None):\r\n        self.game = game\r\n\r\n        self.name = name[0].upper() + name[1:].lower()\r\n        self.is_shiny = self.def_shiny(is_shiny)\r\n        self.id = self.game.get_init_pokemon_id()\r\n        self.random_seed = self.generate_random_seed_number()\r\n\r\n        self.objet_tenu = objet_tenu\r\n        self.status = {\r\n            'Sommeil': False,\r\n            'Brulure': False,\r\n            'Confusion': False,\r\n            'Gel': False,\r\n            'Poison': False,\r\n            'Paralysie': False\r\n            }\r\n\r\n        self.infos = self.get_infos()\r\n\r\n        self.level = int(level)\r\n        self.rarity = self.infos[1]\r\n        self.min_spawn_lv = self.infos[11]\r\n        self.max_spawn_lv = self.infos[12]\r\n\r\n        self.type = self.infos[2]\r\n        self.type2 = self.infos[10]\r\n\r\n        self.bonus_pvmax = 0\r\n        self.multiplicateur_pvmax = 1\r\n        self.pv = round((2 * self.infos[3] * self.level)/100 + self.level + 10) + self.bonus_pvmax  # PV MAX\r\n        self.health = self.pv + self.bonus_pvmax  # PV ACTUELS\r\n\r\n        self.bonus_attack = 0\r\n        self.multiplicateur_attack = 1\r\n        self.base_attack = round((2 * int(self.infos[4]) * self.level)/100 + 5) + self.bonus_attack\r\n        self.attack = self.base_attack\r\n\r\n        self.bonus_defense = 0\r\n        self.multiplicateur_defense = 1\r\n        self.base_defense = round((2 * int(self.infos[5]) * self.level)/100 + 5) + self.bonus_defense\r\n        self.defense = self.base_defense\r\n\r\n        self.bonus_speed = 0\r\n        self.multiplicateur_speed = 1\r\n        self.base_speed = round((2 * int(self.infos[6]) * self.level)/100 + 5) + self.bonus_speed\r\n        self.speed = self.base_speed\r\n\r\n        self.evolution_level = int(self.infos[7])\r\n        self.evolution_name = str(self.infos[8])\r\n        if \"/\" in self.evolution_name:\r\n            evolutions_name_list = self.evolution_name.split(\"/\")\r\n            r = random.Random()\r\n            r.seed(self.random_seed)\r\n            self.evolution_name = r.choice(evolutions_name_list)\r\n            # print(\"Evolution future:\", self.evolution_name)\r\n        self.min_p_lv = int(self.infos[9])\r\n        self.is_alive = True\r\n        self.is_vulnerable = True\r\n\r\n        if self.is_shiny:\r\n            # print(self.name, 'est shiny !!')\r\n            self.icon_image = pygame.image.load(f'assets/game/pokemons_icons/{self.name}_.png')\r\n        else:\r\n            self.icon_image = pygame.image.load(f'assets/game/pokemons_icons/{self.name}.png')\r\n\r\n        self.bonus_attaque_type = None\r\n        self.multiplicateur_bonus_attaque = 1\r\n\r\n        self.item_pourcent_hp_activate = None\r\n        self.passive_heal = 0\r\n\r\n        self.attaque_pool_line = self.find_attaque_pool_line()\r\n        self.attaque_pool = self.init_attaque_pool()\r\n\r\n    def get_infos(self) -> tuple:\r\n        \"\"\"\r\n        Retourne toutes les infos concernant le pokémon\r\n        \"\"\"\r\n\r\n        return self.game.pokemons_list[self.name]\r\n\r\n    def find_attaque_pool_line(self) -> list:\r\n        \"\"\"\r\n        Retourne le nom des attaques du pool d'attaque du pokémon (issu de pokemon_attaque_pool.txt)\r\n        \"\"\"\r\n        with open('pokemon_attaque_pool.txt') as file:\r\n            for line in file.readlines():\r\n                if line.split()[0] == self.name:\r\n                    return line.split()[1].split(',')\r\n\r\n    def init_attaque_pool(self):\r\n        attaque_pool = [None, None, None, None]\r\n        if len(self.attaque_pool_line) <= 4:\r\n            i = 0\r\n            for attaque_name in self.attaque_pool_line:\r\n                attaque_pool[i] = (attaques.Attaque(attaque_name))\r\n                i += 1\r\n\r\n        else:\r\n            attaque_name_list = random.sample(self.attaque_pool_line, 4)\r\n            i = 0\r\n            for attaque_name in attaque_name_list:\r\n                attaque_pool[i] = (attaques.Attaque(attaque_name))\r\n                i += 1\r\n\r\n        return attaque_pool\r\n\r\n    def level_up(self, nb_lv=1):\r\n        self.level += nb_lv\r\n        diff = self.pv - self.health\r\n        self.pv = round((round((2*int(self.infos[3])*self.level)/100 + self.level + 10) + self.bonus_pvmax) * self.multiplicateur_pvmax)\r\n        self.health = self.pv - diff\r\n        self.base_attack = round((round((2 * int(self.infos[4]) * self.level)/100 + 5) + self.bonus_attack) * self.multiplicateur_attack)\r\n        self.base_defense = round((round((2 * int(self.infos[5]) * self.level)/100 + 5) + self.bonus_defense) * self.multiplicateur_defense)\r\n        self.base_speed = round((round((2 * int(self.infos[6]) * self.level)/100 + 5) + self.bonus_speed) * self.multiplicateur_speed)\r\n\r\n    def evolution(self):\r\n        if self.evolution_name == '0':\r\n            print(\"Ce pokémon n'a pas d'évolution(s)\")\r\n            return self\r\n        else:\r\n            if self.level >= self.evolution_level:\r\n                return Pokemon(self.evolution_name, self.level, self.game, self.is_shiny, objet_tenu=self.objet_tenu)\r\n            else:\r\n                return self\r\n\r\n    def full_heal(self):\r\n        self.health = self.pv\r\n\r\n    def get_id(self):\r\n        return self.id\r\n\r\n    def get_stats(self):\r\n        return self.pv, self.attack, self.defense, self.speed\r\n\r\n    def get_bonus_stats(self):\r\n        return self.bonus_pvmax, self.bonus_attack, self.bonus_defense, self.bonus_speed\r\n\r\n    def get_level(self):\r\n        return self.level\r\n\r\n    def get_type(self):\r\n        return self.type\r\n\r\n    def get_type2(self):\r\n        return self.type2\r\n\r\n    def get_name(self):\r\n        return self.name\r\n\r\n    def get_icon(self):\r\n        return self.icon_image\r\n\r\n    def get_attaque_pool(self):\r\n        return self.attaque_pool\r\n\r\n    def heal(self, value):\r\n        self.health += value\r\n        if self.health > self.pv:\r\n            self.health = self.pv\r\n\r\n    def damage(self, amount):\r\n        self.health -= amount\r\n        if self.health <= 0:\r\n            self.is_alive = False\r\n            self.health = 0\r\n\r\n    def attaque(self, pokemon, attaque) -> list:\r\n        \"\"\"\r\n        Attaque le pokémon renseigné en parametre avec l'attaque prise en entrée.\r\n        Renvoie une liste contenant :\r\n            - True si l'attaque a abouti, False sinon\r\n            - 'None' si l'attaque n'a pas appliqué d'effet à personne, (<nom_effet>, <self ou pokemon>) sinon\r\n        \"\"\"\r\n        attaque_infos = []\r\n\r\n\r\n        precision_value = random.randint(0, 100)\r\n        print(f'{attaque.name}: {attaque.precision} | {precision_value}')\r\n        if precision_value < attaque.precision:\r\n\r\n            degats = 0\r\n            if attaque.puissance != 0 and pokemon.is_vulnerable:\r\n\r\n                cm = 1\r\n                # Calcul avec stab ( attaque de type maternel )\r\n                if attaque.type in [self.type, self.type2]:\r\n                    cm *= 1.5\r\n\r\n                # Calcul avec affinités des types\r\n                cm *= game_infos.get_mutiliplicateur(attaque.type, pokemon.type)\r\n\r\n                if not pokemon.type2 == 'NoType':\r\n                    cm *= game_infos.get_mutiliplicateur(attaque.type, pokemon.type2)\r\n\r\n                # Calcul avec taux de crit\r\n                t = round(int(self.infos[6]) / 2) * attaque.taux_crit\r\n                ncrit = random.randint(0, 256)\r\n                if ncrit < t:\r\n                    crit = True\r\n                else:\r\n                    crit = False\r\n\r\n                if crit:\r\n                    cm *= (2 * self.level + 5) / (self.level + 5)\r\n                    print(f'CRITIQUE DE {self.name}')\r\n\r\n                if self.objet_tenu is not None:\r\n                    if self.objet_tenu.type is None or self.objet_tenu.type == attaque.type:\r\n                        cm *= self.objet_tenu.multiplicateur_attaque_dmg\r\n                        print(f\"Augmentation des dégats de l'attaque de {self.objet_tenu.multiplicateur_attaque_dmg*100}%\")\r\n                random_cm = random.randint(85, 100)\r\n                cm = cm * random_cm / 100\r\n\r\n                if attaque.puissance == \"level\":\r\n                    puissance = self.level\r\n\r\n                elif attaque.puissance == \"pv*0.5\":\r\n                    puissance = pokemon.health // 2\r\n                elif attaque.bool_special_puissance:\r\n                    if attaque.special_puissance[0] == 'v':\r\n                        if self.speed <= pokemon.speed:\r\n                            puissance = int(attaque.puissance.split(\"-\")[0])\r\n                        else:\r\n                            puissance = int(attaque.puissance.split(\"-\")[1])\r\n                    elif attaque.special_puissance[0] == 'r':\r\n                        values = attaque.special_puissance[1].split(\"-\")\r\n                        puissance = random.randint(int(values[0]), int(values[1]))\r\n                    else:\r\n                        puissance = attaque.puissance\r\n                else:\r\n                    puissance = attaque.puissance\r\n\r\n                if attaque.special_puissance == 'c':\r\n                    degats = attaque.puissance\r\n                elif attaque.puissance == \"effort\":\r\n                    degats = pokemon.pv - self.health\r\n                elif attaque.puissance == \"ennemy_pv\":\r\n                    degats = pokemon.pv*2\r\n                elif attaque.special_effect[0] == \"use_opponent_attack_stat\":\r\n                    degats = round((((((self.level * 0.4 + 2) * pokemon.attack * puissance) / self.defense) / 50) + 2) * cm)\r\n                else:\r\n                    degats = round((((((self.level * 0.4 + 2) * self.attack * puissance) / self.defense) / 50) + 2) * cm)\r\n\r\n                pokemon.damage(degats)\r\n\r\n            for effet in attaque.special_effect:\r\n                if not effet[0] == 'None':\r\n                    if effet[0] == 'taken_dmg':\r\n                        value = int(effet[1])\r\n                        self.is_vulnerable = False\r\n                        self.damage(value)\r\n                    elif effet[0] == 'heal_on_maxpv':\r\n                        coef = float(effet[1])\r\n                        self.health += round(self.pv*coef)\r\n                        if self.health > self.pv:\r\n                            self.health = self.pv\r\n                    elif effet[0] == 'heal_on_atk':\r\n                        coef = float(effet[1][:-4])\r\n                        self.heal(round(degats*coef))\r\n                    elif effet[0] == 'self.pv':\r\n                        self.damage(round(degats*float(effet[1][:-4])))\r\n                    elif effet[0] == 'self-status':\r\n                        r_value = random.randint(0, 99)\r\n                        if r_value < int(effet[2]):\r\n                            self.status[effet[1]] = True\r\n                            attaque_infos = [True, (effet[1], self)]\r\n\r\n            if pokemon.is_vulnerable:\r\n                if attaque.special_effect[0][0] == \"status\":\r\n                    r = random.randint(0, 99)\r\n                    if r < int(attaque.special_effect[0][2]):\r\n                        pokemon.status[attaque.special_effect[0][1]] = True\r\n                        print(attaque.special_effect[0][1], 'appliqué sur', pokemon.name)\r\n                        attaque_infos = [True, (attaque.special_effect[0][1], pokemon)]\r\n                    else:\r\n                        attaque_infos = [True, None]\r\n                else:\r\n                    attaque_infos = [True, None]\r\n            else:\r\n                attaque_infos = [True, None]\r\n\r\n        else:\r\n            print(f'{attaque.name_} ratée')\r\n            attaque_infos = [False, None]\r\n\r\n        return attaque_infos\r\n\r\n    def reset_status(self):\r\n        self.status = {\r\n            'Sommeil': False,\r\n            'Brulure': False,\r\n            'Confusion': False,\r\n            'Gel': False,\r\n            'Poison': False,\r\n            'Paralysie': False\r\n            }\r\n\r\n    def reset_attaque_fight(self):\r\n        for attaque in self.attaque_pool:\r\n            if attaque is not None:\r\n                print(1)\r\n                if attaque.bool_special_precision:\r\n                    print(2)\r\n                    if attaque.special_precision[0] == 'd':\r\n                        print(3)\r\n                        attaque.precision = int(attaque.special_precision[1].split(\"-\")[0])\r\n\r\n    def reset_turn_effects(self):\r\n        self.is_vulnerable = True\r\n\r\n    def update_item_turn_effects(self):\r\n        \"\"\"\r\n        Methode qui actualise les effets des objets à la fin d'un tour de combat\r\n        \"\"\"\r\n\r\n        assert self.objet_tenu is not None, \"Erreur: tentative d'update sur un objet inexistant\"\r\n\r\n        if self.is_alive:\r\n            if self.item_pourcent_hp_activate is not None:\r\n                print(self.pv*self.item_pourcent_hp_activate/100)\r\n                if self.health <= self.pv*self.item_pourcent_hp_activate/100:\r\n                    self.health += self.objet_tenu.heal_value\r\n                    if self.health > self.pv:\r\n                        self.health = self.pv\r\n\r\n                    self.objet_tenu = None\r\n\r\n    def reset_stats(self):\r\n        self.attack = self.base_attack\r\n        self.defense = self.base_defense\r\n        self.speed = self.base_speed\r\n\r\n    def use_item(self, item):\r\n\r\n        if item.bool_revive_effect:\r\n            self.is_alive = True\r\n\r\n        if self.is_alive:\r\n            self.heal(item.heal_value)\r\n\r\n        self.bonus_attaque_type = item.type\r\n        self.multiplicateur_bonus_attaque = item.multiplicateur_attaque_dmg\r\n        if item.stat == 'pv':\r\n            self.pv += item.bonus_stat\r\n            self.health += item.bonus_stat\r\n            self.bonus_pvmax += item.bonus_stat\r\n        elif item.stat == 'atk':\r\n            self.attack += item.bonus_stat\r\n            self.bonus_attack += item.bonus_stat\r\n        elif item.stat == 'def':\r\n            self.defense += item.bonus_stat\r\n            self.bonus_defense += item.bonus_stat\r\n        elif item.stat == 'vit':\r\n            self.speed += item.bonus_stat\r\n            self.bonus_speed += item.bonus_stat\r\n\r\n        for status in self.status:\r\n            if item.removed_status[status]:\r\n                self.status[status] = False\r\n\r\n        self.pv = round(self.pv * item.multiplicateur_pvmax)\r\n        self.health = round(self.health * item.multiplicateur_pvmax)\r\n\r\n        for stat in item.multiplicateur_stats:\r\n            if not item.multiplicateur_stats[stat] == 1:\r\n                if stat == 'pv':\r\n                    diff = self.pv - self.health\r\n                    self.multiplicateur_pvmax = item.multiplicateur_stats[stat]\r\n                    self.pv = round(self.pv * item.multiplicateur_stats[stat])\r\n                    self.health = self.pv - diff\r\n                elif stat == 'atk':\r\n                    self.multiplicateur_attack = item.multiplicateur_stats[stat]\r\n                    self.attack = round(self.attack * item.multiplicateur_stats[stat])\r\n                elif stat == 'def':\r\n                    self.multiplicateur_defense = item.multiplicateur_stats[stat]\r\n                    self.defense = round(self.defense * item.multiplicateur_stats[stat])\r\n                elif stat == 'vit':\r\n                    self.multiplicateur_speed = item.multiplicateur_stats[stat]\r\n                    self.speed = round(self.speed * item.multiplicateur_stats[stat])\r\n\r\n        if not item.bonus_lv == 0:\r\n            self.level_up(item.bonus_lv)\r\n\r\n    def give_item(self, item):\r\n        self.objet_tenu = item\r\n\r\n        self.bonus_attaque_type = self.objet_tenu.type\r\n        self.multiplicateur_bonus_attaque = self.objet_tenu.multiplicateur_attaque_dmg\r\n\r\n        if self.objet_tenu.stat == 'pv':\r\n            self.pv += self.objet_tenu.bonus_stat\r\n            self.health += self.objet_tenu.bonus_stat\r\n            self.bonus_pvmax += self.objet_tenu.bonus_stat\r\n        elif self.objet_tenu.stat == 'atk':\r\n            self.attack += self.objet_tenu.bonus_stat\r\n            self.bonus_attack += self.objet_tenu.bonus_stat\r\n        elif self.objet_tenu.stat == 'def':\r\n            self.defense += self.objet_tenu.bonus_stat\r\n            self.bonus_defense += self.objet_tenu.bonus_stat\r\n        elif self.objet_tenu.stat == 'vit':\r\n            self.speed += self.objet_tenu.bonus_stat\r\n            self.bonus_speed += self.objet_tenu.bonus_stat\r\n\r\n        self.item_pourcent_hp_activate = self.objet_tenu.pv_pourcent_activate\r\n\r\n        for status in self.status:\r\n            if self.objet_tenu.removed_status[status]:\r\n                self.status[status] = False\r\n\r\n        if self.objet_tenu.multiplicateur_pvmax != 1:\r\n            diff = self.pv - self.health\r\n            self.pv = round(self.pv * self.objet_tenu.multiplicateur_pvmax)\r\n            self.health = self.pv - diff\r\n\r\n        self.passive_heal = self.objet_tenu.heal_after_each_fight\r\n\r\n        for stat in self.objet_tenu.multiplicateur_stats:\r\n            if not self.objet_tenu.multiplicateur_stats[stat] == 1:\r\n                if stat == 'pv':\r\n                    diff = self.pv - self.health\r\n                    self.bonus_pvmax += round(self.pv * self.objet_tenu.multiplicateur_stats[stat]) - self.pv\r\n                    self.pv = round(self.pv * self.objet_tenu.multiplicateur_stats[stat])\r\n                    self.health = self.pv - diff\r\n                elif stat == 'atk':\r\n                    self.bonus_attack += round(self.attack * self.objet_tenu.multiplicateur_stats[stat]) - self.attack\r\n                    self.attack = round(self.attack * self.objet_tenu.multiplicateur_stats[stat])\r\n                elif stat == 'def':\r\n                    self.bonus_defense += round(self.defense * self.objet_tenu.multiplicateur_stats[stat]) - self.defense\r\n                    self.defense = round(self.defense * self.objet_tenu.multiplicateur_stats[stat])\r\n                elif stat == 'vit':\r\n                    self.bonus_speed += round(self.speed * self.objet_tenu.multiplicateur_stats[stat]) - self.speed\r\n                    self.speed = round(self.speed * self.objet_tenu.multiplicateur_stats[stat])\r\n\r\n    def def_shiny(self, is_shiny):\r\n        if self.game.player.always_shiny_on:\r\n            return True\r\n        elif is_shiny is None:\r\n            n = random.randint(1, 256)\r\n            if n == 137:\r\n                return True\r\n            else:\r\n                return False\r\n        elif is_shiny:\r\n            return True\r\n        else:\r\n            return False\r\n\r\n    def generate_random_seed_number(self):\r\n        return int(str(random.randint(0, 255))\r\n                   + str(random.randint(0, 255))\r\n                   + str(random.randint(0, 255))\r\n                   + str(random.randint(0, 255)))\r\n\r\n\r\nif __name__ == \"__main__\":\r\n    pass\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/pokemon.py b/pokemon.py
--- a/pokemon.py	
+++ b/pokemon.py	
@@ -465,4 +465,4 @@
 
 
 if __name__ == "__main__":
-    pass
+   print(bool(0))
